<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>🎨 溢彩畫冊 Puzzle</title>
  <style>
    :root{
      --bg:#0b0f14;--panel:#111825;--panel-2:#0f1520;--text:#e8eefc;--muted:#9aa7bd;--accent:#6ea8fe;--accent-2:#9b8cff;--ok:#3bd671;--bad:#ff6b6b;--warn:#ffcc66;
      --cell:78px; --gap:10px; --radius:18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:radial-gradient(1200px 800px at 80% -10%,#1b2440 0%,transparent 60%),
                 radial-gradient(900px 600px at -10% 110%,#1a2a3a 0%,transparent 60%),var(--bg);
         color:var(--text);font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
    .wrap{max-width:980px;margin:24px auto;padding:16px}
    header{display:flex;gap:12px;align-items:center;justify-content:space-between;margin-bottom:14px}
    .title{display:flex;align-items:center;gap:12px}
    .logo{width:40px;height:40px;border-radius:12px;background:linear-gradient(135deg,var(--accent),var(--accent-2));filter:drop-shadow(0 6px 18px rgba(110,168,254,.35))}
    h1{font-size:20px;margin:0;letter-spacing:.3px}

    .panel{background:linear-gradient(180deg,var(--panel),var(--panel-2));border:1px solid rgba(255,255,255,.06);
           box-shadow:0 8px 24px rgba(0,0,0,.35);border-radius:20px;padding:16px}
    .hud{display:grid;grid-template-columns:1fr auto auto;gap:12px;align-items:center}
    .hud .info{display:flex;gap:16px;flex-wrap:wrap}
    .chip{padding:8px 12px;border-radius:999px;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.08);font-size:13px}
    .target{display:inline-flex;align-items:center;gap:8px}
    .dot{width:14px;height:14px;border-radius:50%;border:2px solid rgba(255,255,255,.2)}

    .controls{display:flex;gap:8px;flex-wrap:wrap}
    button{background:#121a29;border:1px solid rgba(255,255,255,.08);color:var(--text);padding:10px 14px;border-radius:14px;cursor:pointer;
      transition:.15s ease transform, .15s ease background, .15s ease opacity; font-weight:600; letter-spacing:.2px}
    button:hover{transform:translateY(-1px);background:#172233}
    button:disabled{opacity:.5;cursor:not-allowed;transform:none}
    .primary{background:linear-gradient(135deg,var(--accent),var(--accent-2));border:none}
    .primary:hover{filter:brightness(1.05)}
    .danger{background:linear-gradient(135deg,#ff6b6b,#ff9b8c);border:none}

    .game{margin-top:16px;display:grid;grid-template-columns: 320px 1fr; gap:16px}

    .left{display:flex;flex-direction:column;gap:16px}

    .level-list{max-height:420px;overflow:auto}
    .level{display:flex;align-items:center;justify-content:space-between;padding:10px 12px;border-radius:14px;border:1px solid rgba(255,255,255,.06);
      background:rgba(255,255,255,.03);margin-bottom:8px}
    .level.locked{opacity:.6}
    .level .meta{display:flex;align-items:center;gap:10px}
    .badge{font-size:12px;padding:4px 8px;border-radius:999px;border:1px solid rgba(255,255,255,.12);background:rgba(255,255,255,.06)}

    .board-wrap{display:flex;align-items:center;justify-content:center}
    .board{display:grid;gap:var(--gap);padding:16px;background:linear-gradient(180deg,#0e1420,#0a111b);
      border-radius:20px;border:1px solid rgba(255,255,255,.06);box-shadow:inset 0 0 0 1px rgba(255,255,255,.06),0 12px 30px rgba(0,0,0,.35)}
    .cell{width:var(--cell);height:var(--cell);border-radius:var(--radius);position:relative;overflow:hidden;cursor:pointer;transform:translateZ(0)}
    .cell::after{content:"";position:absolute;inset:0;border-radius:inherit;border:1px solid rgba(0,0,0,.15);box-shadow:inset 0 6px 12px rgba(255,255,255,.12)}
    .cell .pulse{position:absolute;inset:-6px;border-radius:inherit;opacity:0;animation:pulse .35s ease-out}
    @keyframes pulse{0%{opacity:.65;transform:scale(.9)}100%{opacity:0;transform:scale(1.12)}}

    .rulebar{display:flex;gap:10px;flex-wrap:wrap}
    .rule{display:flex;align-items:center;gap:8px;background:rgba(255,255,255,.05);border:1px solid rgba(255,255,255,.08);padding:8px 10px;border-radius:12px}
    .rule .arrow{opacity:.7}

    .toast{position:fixed;bottom:20px;left:50%;transform:translateX(-50%);padding:12px 16px;border-radius:12px;background:rgba(20,28,44,.9);border:1px solid rgba(255,255,255,.12);display:none}

    .footer{margin-top:16px;color:var(--muted);font-size:12px;opacity:.9}
    .kbd{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace;padding:2px 6px;border-radius:6px;border:1px solid rgba(255,255,255,.2);background:rgba(255,255,255,.06)}

    @media (max-width: 900px){
      .game{grid-template-columns:1fr}
      .board{margin:auto}
    }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="title"><div class="logo"></div><h1>溢彩畫冊 Puzzle</h1></div>
      <div class="controls">
        <button id="btn-undo" title="Undo (Z)">復原 ⟲</button>
        <button id="btn-reset" class="danger" title="Reset (R)">重開 ↺</button>
        <button id="btn-hint" class="primary" title="Hint (H)">提示 💡</button>
      </div>
    </header>

    <div class="panel hud">
      <div class="info">
        <span class="chip">關卡：<strong id="level-name">-</strong></span>
        <span class="chip">步數：<strong id="moves">0</strong>/<span id="move-limit">-</span></span>
        <span class="chip">目標：<span class="target"><span class="dot" id="target-dot"></span><b id="target-name">—</b></span></span>
        <span class="chip">尺寸：<b id="size">—</b></span>
      </div>
      <div class="rulebar" id="rulebar"></div>
      <div class="controls">
        <button id="btn-prev">⟵ 上一關</button>
        <button id="btn-next">下一關 ⟶</button>
      </div>
    </div>

    <div class="game">
      <div class="left">
        <div class="panel">
          <h3 style="margin:6px 0 10px">關卡列表</h3>
          <div class="level-list" id="level-list"></div>
        </div>
        <div class="panel">
          <h3 style="margin:6px 0 10px">玩法說明</h3>
          <p style="margin:8px 0;color:var(--muted)">點擊格子會依「染色規則」向周圍擴散：當你點某色 A 的格子，四方向相鄰、顏色等於 <b>規則[A]</b> 的格子會被立即染成 A。目標是在限定步數內把全盤染成指定顏色。</p>
          <ul style="margin:0 0 0 18px;color:var(--muted)">
            <li>提示 <span class="kbd">H</span>：推薦一次能轉最多格子的點。</li>
            <li>復原 <span class="kbd">Z</span>、重開 <span class="kbd">R</span>。</li>
            <li>通關會自動解鎖下一關。</li>
          </ul>
        </div>
        <div class="panel footer">© 2025 溢彩畫冊風格益智遊戲（純前端，適合 GitHub Pages）</div>
      </div>

      <div class="panel board-wrap">
        <div id="board" class="board" aria-label="Board"></div>
      </div>
    </div>
  </div>

  <div id="toast" class="toast"></div>

  <script>
    // ======= 顏色與工具 =======
    const COLORS = [
      {key:'red',    name:'紅',  hex:'#ff6b6b'},
      {key:'green',  name:'綠',  hex:'#3bd671'},
      {key:'blue',   name:'藍',  hex:'#6ea8fe'},
      {key:'yellow', name:'黃',  hex:'#ffcc66'},
      {key:'purple', name:'紫',  hex:'#9b8cff'},
      {key:'teal',   name:'青',  hex:'#36d0c6'}
    ];
    const colorMap = Object.fromEntries(COLORS.map(c=>[c.key,c]));

    const el = sel=>document.querySelector(sel);
    const toast = (msg,ms=1400)=>{ const t=el('#toast'); t.textContent=msg; t.style.display='block'; setTimeout(()=>t.style.display='none',ms); };

    // ======= 關卡資料（可自行擴充）=======
    // 每關：size, palette, target, moveLimit, rules(from->to), grid(顏色key)
    const LEVELS = [
      {
        id:1, name:'新月星輝', size:4, moveLimit:8,
        palette:['red','blue','yellow','green'], target:'blue',
        rules:{ red:'green', green:'yellow', yellow:'blue', blue:'red' },
        grid:[
          ['red','green','yellow','blue'],
          ['yellow','blue','red','green'],
          ['green','yellow','blue','red'],
          ['blue','red','green','yellow']
        ]
      },
      {
        id:2, name:'第一關', size:5, moveLimit:10,
        palette:['red','purple','yellow','blue'], target:'yellow',
        rules:{ red:'yellow', yellow:'blue', blue:'purple', purple:'red' },
        grid:[
          ['red','purple','yellow','blue','red'],
          ['yellow','blue','purple','red','yellow'],
          ['blue','red','yellow','purple','blue'],
          ['purple','yellow','blue','red','purple'],
          ['red','blue','purple','yellow','red']
        ]
      },
      {
        id:3, name:'第二關', size:5, moveLimit:11,
        palette:['teal','blue','green','yellow'], target:'teal',
        rules:{ teal:'green', green:'blue', blue:'yellow', yellow:'teal' },
        grid:[
          ['teal','green','blue','yellow','green'],
          ['blue','yellow','teal','green','blue'],
          ['yellow','teal','green','blue','yellow'],
          ['green','blue','yellow','teal','green'],
          ['blue','yellow','teal','green','blue']
        ]
      },
      {
        id:4, name:'第三關', size:6, moveLimit:14,
        palette:['red','green','blue','purple'], target:'purple',
        rules:{ red:'blue', blue:'green', green:'purple', purple:'red' },
        grid:(()=>{
          const g=[]; for(let i=0;i<6;i++){ const row=[]; for(let j=0;j<6;j++){
            row.push(['red','green','blue','purple'][(i+j)%4]);
          } g.push(row);} return g; })()
      },
      {
        id:5, name:'第四關', size:6, moveLimit:15,
        palette:['red','yellow','blue','teal','green'], target:'teal',
        rules:{ red:'yellow', yellow:'green', green:'blue', blue:'teal', teal:'red' },
        grid:(()=>{
          const base=['red','yellow','green','blue','teal'];
          const g=[]; for(let i=0;i<6;i++){ const row=[]; for(let j=0;j<6;j++){
            row.push(base[(i*2+j)%5]);
          } g.push(row);} return g; })()
      },
      {
        id:6, name:'第五關', size:7, moveLimit:18,
        palette:['red','green','blue','yellow','purple'], target:'red',
        rules:{ red:'purple', purple:'yellow', yellow:'green', green:'blue', blue:'red' },
        grid:(()=>{
          const p=['red','green','blue','yellow','purple'];
          const g=[]; for(let i=0;i<7;i++){ const row=[]; for(let j=0;j<7;j++){
            row.push(p[(i+j*2)%5]);
          } g.push(row);} return g; })()
      }
    ];

    // ======= 狀態 =======
    const state = {
      levelIndex: 0,
      grid: [],
      moves: 0,
      history: [], // 用於復原
      unlockedMax: parseInt(localStorage.getItem('yy_color_unlocked')||'1',10)
    };

    // ======= 初始化 =======
    const boardEl = el('#board');
    const rulebarEl = el('#rulebar');
    const levelNameEl = el('#level-name');
    const movesEl = el('#moves');
    const moveLimitEl = el('#move-limit');
    const sizeEl = el('#size');
    const targetDotEl = el('#target-dot');
    const targetNameEl = el('#target-name');

    // 生成格子 UI
    function renderBoard(level){
      const {size} = level;
      boardEl.style.setProperty('--cell', size>=7? '56px' : size>=6? '64px' : '78px');
      boardEl.style.gridTemplateColumns = `repeat(${size}, var(--cell))`;
      boardEl.innerHTML = '';
      state.grid = level.grid.map(row=>row.slice());

      for(let i=0;i<size;i++){
        for(let j=0;j<size;j++){
          const c = state.grid[i][j];
          const cell = document.createElement('button');
          cell.className = 'cell';
          cell.style.background = colorMap[c].hex;
          cell.setAttribute('data-i', i);
          cell.setAttribute('data-j', j);
          cell.setAttribute('aria-label', `${i},${j} ${colorMap[c].name}`);
          cell.addEventListener('click', ()=> onClickCell(i,j));
          boardEl.appendChild(cell);
        }
      }
    }

    // 渲染規則列
    function renderRules(level){
      rulebarEl.innerHTML='';
      Object.entries(level.rules).forEach(([from,to])=>{
        const pill=document.createElement('div'); pill.className='rule';
        const a=document.createElement('span'); a.className='dot'; a.style.background=colorMap[from].hex; a.title=colorMap[from].name;
        const b=document.createElement('span'); b.className='dot'; b.style.background=colorMap[to].hex; b.title=colorMap[to].name;
        const arr=document.createElement('span'); arr.className='arrow'; arr.textContent='染 →';
        pill.append(a,arr,b); rulebarEl.appendChild(pill);
      });
    }

    function setHUD(level){
      levelNameEl.textContent = `${level.id}. ${level.name}`;
      movesEl.textContent = state.moves = 0;
      moveLimitEl.textContent = level.moveLimit;
      sizeEl.textContent = `${level.size}×${level.size}`;
      targetDotEl.style.background = colorMap[level.target].hex;
      targetNameEl.textContent = colorMap[level.target].name;
    }

    function loadLevel(idx){
      state.levelIndex = idx;
      const level = LEVELS[idx];
      // 深拷貝避免直接改原資料
      const g = level.grid.map(row=>row.slice());
      level._gridBackup = g.map(r=>r.slice());
      state.history = [];
      setHUD(level); renderRules(level); renderBoard(level);
      renderLevelList();
    }

    function resetLevel(){
      const level = LEVELS[state.levelIndex];
      level.grid = level._gridBackup.map(r=>r.slice());
      loadLevel(state.levelIndex);
    }

    // ======= 規則擴散演算 =======
    const DIRS = [[1,0],[-1,0],[0,1],[0,-1]]; // 4-neighbors

    function onClickCell(i,j){
      const level = LEVELS[state.levelIndex];
      const fromColor = state.grid[i][j];
      const needColor = level.rules[fromColor];
      // 保存歷史
      pushHistory();

      // 自身不變色，僅作為「染色源」；擴散：凡相鄰顏色 == needColor -> 變 fromColor
      const q=[[i,j]]; // 從點擊源出發，層層擴散（只穿越被染成功的格）
      const seen=new Set([i+','+j]);
      while(q.length){
        const [x,y]=q.shift();
        for(const [dx,dy] of DIRS){
          const nx=x+dx, ny=y+dy;
          if(nx<0||ny<0||nx>=level.size||ny>=level.size) continue;
          const key=nx+','+ny; if(seen.has(key)) continue;
          if(state.grid[nx][ny]===needColor){
            state.grid[nx][ny]=fromColor;
            seen.add(key);
            q.push([nx,ny]);
            paintCell(nx,ny, fromColor);
          }
        }
      }

      state.moves++;
      movesEl.textContent = state.moves;
      checkWin();
    }

    function paintCell(i,j,colorKey){
      const idx = i*LEVELS[state.levelIndex].size + j;
      const cell = boardEl.children[idx];
      if(!cell) return;
      // 動畫閃爍
      const pulse=document.createElement('div'); pulse.className='pulse'; pulse.style.background=colorMap[colorKey].hex;
      cell.appendChild(pulse); setTimeout(()=>pulse.remove(), 360);
      cell.style.background = colorMap[colorKey].hex;
    }

    // ======= 勝負判定 =======
    function checkWin(){
      const level = LEVELS[state.levelIndex];
      const {target, moveLimit} = level;
      // 全盤是否單一色 & 是否為目標色
      let allTarget=true; outer: for(let i=0;i<level.size;i++){
        for(let j=0;j<level.size;j++){
          if(state.grid[i][j]!==target){ allTarget=false; break outer; }
        }
      }
      if(allTarget){
        toast('✅ 通關！解鎖下一關');
        // 解鎖
        if(level.id===state.unlockedMax && state.unlockedMax<LEVELS.length){
          state.unlockedMax++; localStorage.setItem('yy_color_unlocked', String(state.unlockedMax));
        }
        // 自動跳下一關
        if(state.levelIndex < LEVELS.length-1){ loadLevel(state.levelIndex+1); }
        return;
      }
      if(state.moves>=moveLimit){
        toast('❌ 失敗，已達步數上限');
        // 禁止點擊：暫時用覆蓋重繪
        setTimeout(resetLevel, 600);
      }
    }

    // ======= 提示：找出一次能染最多格的位置 =======
    function bestHint(){
      const level = LEVELS[state.levelIndex];
      let best=null, bestGain=0;
      for(let i=0;i<level.size;i++){
        for(let j=0;j<level.size;j++){
          const from=state.grid[i][j];
          const need=level.rules[from];
          let gain=0; const seen=new Set([i+','+j]); const q=[[i,j]];
          while(q.length){
            const [x,y]=q.shift();
            for(const [dx,dy] of DIRS){
              const nx=x+dx, ny=y+dy; const k=nx+','+ny;
              if(nx<0||ny<0||nx>=level.size||ny>=level.size||seen.has(k)) continue;
              if(state.grid[nx][ny]===need){ gain++; seen.add(k); q.push([nx,ny]); }
            }
          }
          if(gain>bestGain){ bestGain=gain; best=[i,j]; }
        }
      }
      return {pos:best, gain:bestGain};
    }

    function flashHint(){
      const {pos,gain} = bestHint();
      if(!pos){ toast('暫無可用提示'); return; }
      const level = LEVELS[state.levelIndex];
      const idx = pos[0]*level.size + pos[1];
      const cell = boardEl.children[idx];
      cell.style.outline='3px solid var(--accent)';
      setTimeout(()=>cell.style.outline='none', 800);
      toast(`建議點這裡，可擴散 ${gain} 格`);
    }

    // ======= 復原 =======
    function pushHistory(){
      // 儲存一個快照
      const snapshot = state.grid.map(r=>r.slice());
      state.history.push({grid:snapshot, moves:state.moves});
      if(state.history.length>40) state.history.shift();
    }
    function undo(){
      if(!state.history.length) return;
      const last = state.history.pop();
      state.grid = last.grid.map(r=>r.slice());
      state.moves = last.moves;
      movesEl.textContent = state.moves;
      // 重繪棋盤顏色
      const level = LEVELS[state.levelIndex];
      for(let i=0;i<level.size;i++){
        for(let j=0;j<level.size;j++){
          const idx=i*level.size+j; const cell=boardEl.children[idx];
          cell.style.background = colorMap[state.grid[i][j]].hex;
        }
      }
    }

    // ======= 關卡列表/解鎖 =======
    function renderLevelList(){
      const list = el('#level-list');
      list.innerHTML='';
      LEVELS.forEach((lv,idx)=>{
        const item=document.createElement('div'); item.className='level'+(lv.id>state.unlockedMax?' locked':'');
        const meta=document.createElement('div'); meta.className='meta';
        const name=document.createElement('div'); name.innerHTML=`<b>${lv.id}. ${lv.name}</b>`;
        const size=document.createElement('span'); size.className='badge'; size.textContent=`${lv.size}×${lv.size}`;
        const limit=document.createElement('span'); limit.className='badge'; limit.textContent=`步數 ${lv.moveLimit}`;
        meta.append(name,size,limit);
        const go=document.createElement('button'); go.textContent= lv.id>state.unlockedMax ? '🔒' : '開始';
        go.disabled = lv.id>state.unlockedMax;
        go.addEventListener('click', ()=> loadLevel(idx));
        item.append(meta, go); list.appendChild(item);
      });
    }

    // ======= 事件 =======
    el('#btn-reset').addEventListener('click', resetLevel);
    el('#btn-undo').addEventListener('click', undo);
    el('#btn-hint').addEventListener('click', flashHint);

    el('#btn-prev').addEventListener('click', ()=>{
      const idx = Math.max(0, state.levelIndex-1); loadLevel(idx);
    });
    el('#btn-next').addEventListener('click', ()=>{
      const idx = Math.min(LEVELS.length-1, state.levelIndex+1); loadLevel(idx);
    });

    document.addEventListener('keydown', (e)=>{
      if(e.key==='r' || e.key==='R'){ e.preventDefault(); resetLevel(); }
      if(e.key==='z' || e.key==='Z'){ e.preventDefault(); undo(); }
      if(e.key==='h' || e.key==='H'){ e.preventDefault(); flashHint(); }
    });

    // ======= 啟動 =======
    (function init(){
      // 若首次進來，確保至少解鎖第一關
      if(state.unlockedMax<1){ state.unlockedMax=1; localStorage.setItem('yy_color_unlocked','1'); }
      renderLevelList();
      loadLevel(0);
    })();
  </script>
</body>
</html>

